Angular is a JS framework which allows you to create reactive Single-Page-Applications (SPAs).


			How Angular works in browser:

Index.html is the only page served on the client side (browser)

In the project, 'main.ts' is loaded first on runtime (and adds a bunch of 'script' elements in the end of the index.html file in the browser) which basically points to 'app.module' which contains 'bootstrap: [AppComponent]' so basically, the code inside AppComponent gets into index.html inside '<app-root>'



			Components
Components are key features in Angular. You build your whole application by composing it from a couple of components, which are created by us.

Angular uses componnets to build webpages.

We put the rest of the components inside the 'AppComponent', thier selecteor would be added into the 'app.component.html' file

To build a component, create new folder inside the 'app' folder and name it such that folder name = component name. Each component typically should have its own folder. To create the component inisde this folder, convention: '[component_name].component.ts' (eg, 'server.component.ts')


Component = TS class, it has to be exported to be used outside the file it is being defined

naming convention: 'export class ServerComponent' (name of the component, followed by desscription)

To tell angular it is not just any typescript but a component, a decorator(@Component()) is added on top of the class (Decorators enhance your elements you use in code)

To import the decorator : import { Component } from '@angular/core';

You need to pass a JS object to @Component() decorator to configure it 
In the js object: following properties are important: 'selector'and 'templateUrl'



			Modules
To use our own components, some modification is needed in 'app module'
Angular uses modules to basically bundle different pieces, e.g. components of your app into 'packages'
A module is bundle of functionalities of our app and it gives Angular the information which features does my app have and use.

Register your component in 'app.module.ts' inside the array in 'declarations' property in JS object of @NgModule() decorator. 


No 'ts' extension while importing the component, they are added by 'webpack' which bunldes our project automatically.

The property 'imports' in @NgModule() JS object simply allows us to add some other modules to this module

If you generate component through CLI, it is automatically added to app.module.ts, hence recommended to use CLI approach.

			SPEC File details
SPEC file in a component is used for testing.

			Templates
External template file = separate component.html file that gets created inside the component (refernced by 'templateUrl' in the JS object in @Component decorator in component.ts)
Internal template = html code within the component.ts file (refernced by 'template' in the JS object in @Component decorator in component.ts)

Inside the 'template' property in JS object, you can write html code, you can use back-ticks (`) to write multi-line html code. 

Either template or templateUrl must be present in the JS object.

			Component Styles
We can use bootstrap defined html classes for styling or create/overwrite our style just like normal css in component.css

We can make use of 'styleUrls' (an 'array', since multiple stylesheets could be referenced here) to refernce to an eternal css file
and 'styles' (an array of strings) to write inline styles for the component

Can't use both 'styles' and 'styleUrls'. Only one of them can be used!!

			Selector
Selector could be an element, ('app-servers'), could be an attribute ('[app-servers]'), could be class ('.app-severs')

Selecting by id isn't supported by Angular.


			Data Binding
Data Binding = Communication between TypeScript code of component(Business logic) and the template(HTML)

A) Output data from Component to Template ways/forms:
1) String interpolation ({{data}})
2) Property Binding ([property]="data")

B) React to (Users) Events (from Template to Component communication):
1) Event Binding ((event)="expression")

C) Coombination of both = Two-Way-Binding (([ng-Model])="data")

			STRING INTERPOLATION
String interpolation refers to supplying the property(variable) from component to template, where in template '{{}}' syntax is used where in between TypeScript expression that could be resolved into string at the end could be written. We can't write multi-line expression between the {{}} synatx in template, can't write block expressions (if/for blocks), can write a ternary expression.

			PROPERTY BINDING
There are a lot of times where we can use 'string interpolation' or 'property binding'.
Suppose you want to bind a variable(property) you defined to an attribute defined in HTML code, which could be changed dynamically, you enclose that attribute inside '[]'.

Square brackets ([]) indicate to Angular that we are using property binding, i.e. we want to dynamically bind some property.

In the end, a normal HTML only sets a specific property on the underlying DOM element. (Each HTML we use is parsed by the browser and kind of translated into an element on the document object model (DOM). An element in DOM has a couple of properties, a lot of it can't even be set through attributes on the HTML element). One of the properties is the 'disabled' property, which can be set through disabled attribute.

But here([disabled]), we aren't using the disabled attribute but we are directly binding to this native disabled property this HTML element has!

You give a value to the property by an expression between the quotation marks ("") (which for 'disabled' property resolves to a boolean) (For other properties, other types may be required.)

We bind to the HTML element property(native element property) the TypeScript property. So as soon as the TypeScript property changes, the property of the HTML element gets changed in the DOM at runtime.

Besides binding to HTML properties, we can also bind to other properties for example of 'directives' and our 'own components'.


			PROPERTY BINDING VS STRING INTERPOLATION
When you want to output something in your template, print some text to it, use string interpolation.

If you want to change some property, be that of an HTMl element/directive/component, use property binding.

Don't mix property binding ([HTML_property]="TS_property") and string interpolation({{TS_property}})!

In property binding, between the quotation marks (""), write TypeScript expression which will return the value the HTML property expects. A method could also be called here.


			EVENT BINDING
Generally, the methods that are called in response to an event start with 'on' (Not a fixed rule, but makes it easier to understand that this is a method meant for response to an event.)

Typically, we have onclick attribute on HTML element where we can execute some JavaScript code but we don't use that with Angular.

Event Binding can be done to all the events being made available by the HTMl attribute, you are writing the Angular binding on

Syntax for event binding:
(click)="onCreateServer()"

Between the "", you put in the code you want to execte once the event occurs, often method is called here. Since we want it to be executed when the event occurs we append () at the end of method name. Instead of method we could have put in the code we wish to execute here, not  a very good practice if there is lot of logic.

Passing and Using Data with Event Binding:
	'$event' (sort of reserved variable name) is used to give access about the event data. To capture data, '$event' is passed as an arguement to the method we are calling, or used anywhere between these "" in the code we are executing on that event.


			TWO WAY DATABINDING
We need to enable ngModel directive for 2 way databinding to work. For that we need to add FormsModule to the imports[] array in AppModule, also import { FormsModule } from '@angular/forms'.

Two way binding  = combination of property binding and event binding

Combine [](property binding) with ()(event binding) = [(ngModel)](2-way binding)

[(ngModel)] = 'TS_property'


			DIRECTIVES
Directives = Instructions in the DOM
Components are directives(with template) as we place there selector in the templates and accordingly the DOM adds our code in the template where the selecteor is used. 

There are other directive without a template.
e.g.: <p appTurnGreen>Receives a green background</p>

Here, 'appTurnGreen' would be a custom directive we could build.

We typically add directives with attribute selectors, but technically the selecteor of a directive can be configured just like the selecteor of a component, hence we can use CSS classes or the element style, but we use the typical attribute style.


Angular would find this instruction from the component.ts file where we have defined our customed directive using the directive decorator to inform Angular
@Directive({
	selecteor: '[appTurnGreen]'
})

export class TurnGreenDirective{
	...
}

There are a couple of built-in directives.

			ngIf DIRECTIVE
This directive can be used to output data conditionally.

Added as an attribute with *ngIf, * is required because it is a structural directive, i.e. it changes the structure of our DOM.
It either adds the element or doesn't add it.

The value to ngIf is given between the "", the value is an expression which would result in true or false, deciding whether this should be added or not.

ngIf condition can be enhanced by else condition, so in the else element, you can place a local refernce(e.g.: "#noServer") and use the directive component shipped with Angular 'ng-template', it can be used to mark places in the DOM.
We can enhance ngIf by adding else then the local refernce we used in the ng-template component.