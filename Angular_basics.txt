Angular is a JS framework which allows you to create reactive Single-Page-Applications (SPAs).


			How Angular works in browser:

Index.html is the only page served on the client side (browser)

In the project, 'main.ts' is loaded first on runtime (and adds a bunch of 'script' elements in the end of the index.html file in the browser) which basically points to 'app.module' which contains 'bootstrap: [AppComponent]' so basically, the code inside AppComponent gets into index.html inside '<app-root>'



			Components
Components are key features in Angular. You build your whole application by composing it from a couple of components, which are created by us.

Angular uses componnets to build webpages.

We put the rest of the components inside the 'AppComponent', thier selecteor would be added into the 'app.component.html' file

To build a component, create new folder inside the 'app' folder and name it such that folder name = component name. Each component typically should have its own folder. To create the component inisde this folder, convention: '[component_name].component.ts' (eg, 'server.component.ts')


Component = TS class, it has to be exported to be used outside the file it is being defined

naming convention: 'export class ServerComponent' (name of the component, followed by desscription)

To tell angular it is not just any typescript but a component, a decorator(@Component()) is added on top of the class (Decorators enhance your elements you use in code)

To import the decorator : import { Component } from '@angular/core';

You need to pass a JS object to @Component() decorator to configure it 
In the js object: following properties are important: 'selector'and 'templateUrl'



			Modules
To use our own components, some modification is needed in 'app module'
Angular uses modules to basically bundle different pieces, e.g. components of your app into 'packages'
A module is bundle of functionalities of our app and it gives Angular the information which features does my app have and use.

Register your component in 'app.module.ts' inside the array in 'declarations' property in JS object of @NgModule() decorator. 


No 'ts' extension while importing the component, they are added by 'webpack' which bunldes our project automatically.

The property 'imports' in @NgModule() JS object simply allows us to add some other modules to this module

If you generate component through CLI, it is automatically added to app.module.ts, hence recommended to use CLI approach.

			SPEC File details
SPEC file in a component is used for testing.

			Templates
External template file = separate component.html file that gets created inside the component (refernced by 'templateUrl' in the JS object in @Component decorator in component.ts)
Internal template = html code within the component.ts file (refernced by 'template' in the JS object in @Component decorator in component.ts)

Inside the 'template' property in JS object, you can write html code, you can use back-ticks (`) to write multi-line html code. 

Either template or templateUrl must be present in the JS object.

			Component Styles
We can use bootstrap defined html classes for styling or create/overwrite our style just like normal css in component.css

We can make use of 'styleUrls' (an 'array', since multiple stylesheets could be referenced here) to refernce to an eternal css file
and 'styles' (an array of strings) to write inline styles for the component

Can't use both 'styles' and 'styleUrls'. Only one of them can be used!!

			Selector
Selector could be an element, ('app-servers'), could be an attribute ('[app-servers]'), could be class ('.app-severs')

Selecting by id isn't supported by Angular.


			Data Binding
Data Binding = Communication between TypeScript code of component(Business logic) and the template(HTML)

A) Output data from Component to Template ways/forms:
1) String interpolation ({{data}})
2) Property Binding ([property]="data")

B) React to (Users) Events (from Template to Component communication):
1) Event Binding ((event)="expression")

C) Combination of both = Two-Way-Binding (([ng-Model])="data")

			STRING INTERPOLATION
String interpolation refers to supplying the property(variable) from component to template, where in template '{{}}' syntax is used where in between TypeScript expression that could be resolved into string at the end could be written. We can't write multi-line expression between the {{}} synatx in template, can't write block expressions (if/for blocks), can write a ternary expression.

			PROPERTY BINDING
There are a lot of times where we can use 'string interpolation' or 'property binding'.
Suppose you want to bind a variable(property) you defined to an attribute defined in HTML code, which could be changed dynamically, you enclose that attribute inside '[]'.

Square brackets ([]) indicate to Angular that we are using property binding, i.e. we want to dynamically bind some property.

In the end, a normal HTML only sets a specific property on the underlying DOM element. (Each HTML we use is parsed by the browser and kind of translated into an element on the document object model (DOM). An element in DOM has a couple of properties, a lot of it can't even be set through attributes on the HTML element). One of the properties is the 'disabled' property, which can be set through disabled attribute.

But here([disabled]), we aren't using the disabled attribute but we are directly binding to this native disabled property this HTML element has!

You give a value to the property by an expression between the quotation marks ("") (which for 'disabled' property resolves to a boolean) (For other properties, other types may be required.)

We bind to the HTML element property(native element property) the TypeScript property. So as soon as the TypeScript property changes, the property of the HTML element gets changed in the DOM at runtime.

Besides binding to HTML properties, we can also bind to other properties for example of 'directives' and our 'own components'.


			PROPERTY BINDING VS STRING INTERPOLATION
When you want to output something in your template, print some text to it, use string interpolation.

If you want to change some property, be that of an HTMl element/directive/component, use property binding.

Don't mix property binding ([HTML_property]="TS_property") and string interpolation({{TS_property}})!

In property binding, between the quotation marks (""), write TypeScript expression which will return the value the HTML property expects. A method could also be called here.


			EVENT BINDING
Generally, the methods that are called in response to an event start with 'on' (Not a fixed rule, but makes it easier to understand that this is a method meant for response to an event.)

Typically, we have onclick attribute on HTML element where we can execute some JavaScript code but we don't use that with Angular.

Event Binding can be done to all the events being made available by the HTMl attribute, you are writing the Angular binding on

Syntax for event binding:
(click)="onCreateServer()"

Between the "", you put in the code you want to execte once the event occurs, often method is called here. Since we want it to be executed when the event occurs we append () at the end of method name. Instead of method we could have put in the code we wish to execute here, not  a very good practice if there is lot of logic.

Passing and Using Data with Event Binding:
	'$event' (sort of reserved variable name) is used to give access about the event data. To capture data, '$event' is passed as an arguement to the method we are calling, or used anywhere between these "" in the code we are executing on that event.


			TWO WAY DATABINDING
We need to enable ngModel directive for 2 way databinding to work. For that we need to add FormsModule to the imports[] array in AppModule, also import { FormsModule } from '@angular/forms'.

Two way binding  = combination of property binding and event binding

Combine [](property binding) with ()(event binding) = [(ngModel)](2-way binding)

[(ngModel)] = 'TS_property'


			DIRECTIVES
Directives = Instructions in the DOM
Components are directives(with template) as we place there selector in the templates and accordingly the DOM adds our code in the template where the selecteor is used. 

There are other directive without a template.
e.g.: <p appTurnGreen>Receives a green background</p>

Here, 'appTurnGreen' would be a custom directive we could build.

We typically add directives with attribute selectors, but technically the selecteor of a directive can be configured just like the selecteor of a component, hence we can use CSS classes or the element style, but we use the typical attribute style.


Angular would find this instruction from the component.ts file where we have defined our customed directive using the directive decorator to inform Angular
@Directive({
	selecteor: '[appTurnGreen]'
})

export class TurnGreenDirective{
	...
}

There are a couple of built-in directives.

			ngIf DIRECTIVE
This directive can be used to output data conditionally.

Added as an attribute with *ngIf, * is required because it is a structural directive, i.e. it changes the structure of our DOM.
It either adds the element or doesn't add it.

The value to ngIf is given between the "", the value is an expression which would result in true or false, deciding whether this should be added or not.

ngIf condition can be enhanced by else condition, so in the else element, you can place a local refernce(e.g.: "#noServer") and use the directive component shipped with Angular 'ng-template', it can be used to mark places in the DOM.
We can enhance ngIf by adding else then the local refernce we used in the ng-template component.

			ATTRIBUTE DIRECTIVES
Unlike structural directives, attribute directives don't add or remove elements. They only change the element they were placed on.

They look like normal HTML attributes (i.e. without '*').

Constructor = Built in method, each typescript class has which is called once this component is created.

			ngStyle
ngStyle is an attribute directive. It is used to style elements dynamically.
<p [ngStyle]="{'background-color': getColor()}">

In the above example, since the property of this directive is also ngStyle, hence we have done the property binding here on ngStyle directive!

			ngClass
ngClass allows us to dynamically add or remove CSS classes.

Note:
<p [ngStyle]="{'background-color': getColor()}" [ngClass]="{online: serverStatus === 'online'}">Server with ID {{ serverId }} is {{ getServerStatus() }}</p>

In the above example, we have passed a JS object, this is specific to this property of this directive (ngClass).

Each property we may bind to may take a different value.

Like disabled takes true or false, this property of ngClass takes a JS object.

Here JS object of ngClass works like this:
	Key-value pairs. The keys are the CSS class names and values are the conditions determining whether this class should be attached or not.

	In the above example, we have an 'online' class, (we could wrapped inside a quotation mark i.e.
	(<p [ngStyle]="{'background-color': getColor()}" [ngClass]="{'online': serverStatus === 'online'}">Server with ID {{ serverId }} is {{ getServerStatus() }}</p>))

	The condition checking whether the server status is online is the value in the JS object for the key 'online'.


			ngFor DIRECTIVE
ngFor is a structural directive, hence we need to use *, in front of it while using it.
In the right hand of side, we define a local variable for inside a loop, then 'of' then TS property we created in the component.ts file.

e.g.: *ngFor="let server of servers"

Individual elemnts(not index!) of the servers array is given to server in iterations.

Then this server variable can be used in templte.

Note:
	Current index of iteration example:
	<div *ngFor="let buttonClick of buttonClicks; let i=index">
		<!-- Here, i points to current index of the iteration, '=index' is reserved expression -->
		<p [ngStyle]="{backgroundColor: i >= 4 ? 'blue' :''}" [ngClass]="{'future-logs': i >= 4}">{{ buttonClick }}</p>
	</div>


			DEBUGGING
Use 'sourcemaps' in the browser to debug the logical errors. 

			CUSTOM PROPERTY AND EVENT BINDING
Note: Property and Event Binding is not only limited to HTML elements(Native Properties and events) but we can use it with Directives(Custom properties and Events) we can also use it on our own components(Custom properties and Events)

For binding to a custom property on a compoent so that the property can be utilised by other components, decorator '@Input()' has to be given

Assigning an alias to custom properties:
	@Input('srvElement') element: {type: string, name: string, content: string};

and in parent component html:
 <app-server-element [srvElement]="serverElement"></app-server-element>

In case an alias is defined, only that work, not the property defined in the component.

Binding to custom events:
	serverCreated = new EventEmitter<{
    serverName: string;
    serverContent: string;
  }>();

	EventEmiiter is an object in Angular framework which allows to you emit your own events. To be able to bind to the event, we used '@Output()' decorator 
Alias is same as in binding to custom properties:
@Output('bpCreated') blueprintCreated = new EventEmitter<{
    serverName: string;
    serverContent: string;
  }>();
  
  Action on which custom event should be triggered.
  onAddBlueprint() {
    this.blueprintCreated.emit({
      serverName: this.newServerName,
      serverContent: this.newServerContent,
    });
  }
  
 The custom property and event binding are key features in component communication. Through services too, components can communicate with each other.


			VIEW ENCAPSULATION
Generally, in CSS working, it doesn't care in which css file you define the rule, it simply is applied to a whole document normallly. View Encapsulation is a behavior enforced by Angular, meaning CSS properties defined inside the component will be applied to the content of that component, not to any other component outside of it. The way Angular does view encapsulation is by giving the same attribute to all the element in a component.

We can override view encapsulation, add this to @Component in component.ts:
encapsulation: ViewEncapsulation.None

ViewEncapsulation.Emulated is default, hence we don't need to choose that
Using ViewEncapsulation.None prevents angular from adding the attributes to the elements of that particular component. Now if we define any css file for this file, they will get applied globally, not just to this component specifically.


			USING LOCAL REFERENCES IN TEMPLATES
Local Reference can be plced on any HTMl element, you can add it with '#' (e.g.: '#serverName'). This basically gives us a reference to this element, not its value, rather to the whole HTML element with its properties. We can pass this local reference to everywhere inside the tempplate (e.g.:

	<button (click)="onAddServer(serverName)">Add Server</button>
), but we cannot use them as it is inside our typescript code. Since we have called this onAddServer() method isnide our template hence we are able to use serverNameInput, and this way we are able to pass it to the TS code.

			GETTING ACCESS TO THE TEMPLATE AND DOM WITH @ViewChild
With @ViewChild, we get direct access to elements from within our code (earlier we got access to the local-refernce via a method we used where local reference was passed.) Using @ViewChild, we get access to the element even before we call the element. The arguement to ViewChild method is the selector of the element (not like CSS selector, but the name of the local reference as a string as we gave is considered a selector here). We can also give a component as an arguement in the ViewChild() method if we are using that component within other component (e.g. in app-component => @ViewChild(CockpitComponent)), note CockpitComponent has not been passed as a string here, this would get access to the first occurence of the cockpit component in the app component.

ViewChild example with a local reference:

@ViewChild('serverContentInput', { static: false }) 
serverContentInput;

Here, the type of serverContentInput gives ElementRef (not the direct HTMLElement itself)

When passing the reference via ViewChild, it gives us the type 'ElementRef' (an angular type, imported via @angular/core), not the direct element itslef as in case of passing local-reference via method to TS code. We can access the element via a property it has, 'nativeElement' property. With this we get direct access to the elements in our DOM, through @ViewChild.

We can control the properties of the HTML template through our typescript code via Local reference; however not recommended. We should do string interpolation or property binding rather using this method to output something in the DOM. Directives offer a better way of manipulating the DOM.

			
			PROJECTING CONTENT INTO COMPONENTS USING ng-content
This is yet another way to pass data around in our angular application. Sometimes, we have complex HTML code which we want to pass into a component from outside. If we try passing some other HTML code inside the opening and closing tags of our own components, it doesn't work (e.g.

<app-server-element *ngFor="let serverElement of serverElements" [srvElement]="serverElement">
        <!-- Testing if we can pass some other HTML code inside the opening and closing tags of our own components. Result => No, it doesn't work! -->
        <p>
          <strong *ngIf="serverElement.type === 'server'" style="color: red">{{ serverElement.content }}</strong>
          <em *ngIf="serverElement.type === 'blueprint'">{{ serverElement.content }}</em>
        </p>
      </app-server-element>
). It doesn't give any error, but the <p> tag result is not displayed on the DOM. It is the default behavior. Everything you place between the opening and closing tag of your own component, is lost by default. We can change this default behavior by using a directive, ng-content

Say you want to display that complex HTMl code as a part of server-element component template, you simply write <ng-content></ng-content> where the HTML code will reside, using ng-content, Angular will put everything it found between the opening and closing tags of our custom components and place it here. This is called as projection in component where we used ng-content directive/hook.


			UNDERSTANDING THE COMPONENT LIFECYCLE
ngOnInit() is a lifecycle hook of many lifecycle hooks that Angular supports.

If a new component is created in Angular, Angular goes through a couple of steps in the creation process of a component. Angular gives us a chance to hook into these phases and execute some code. We can call some methods which Angular will call while the creation process.


ngOnChanges() ---> Called after a bound input property changes (maybe executed multiple times. Executed right at the start when the component is created, then always whenever one of our bound input properties change, propeties decorated with @Input)

ngOnInit() ---> Called once the component is initialized. Initialization does not mean we can see it, as in it has yet not been added to the DOM, but Angular finished the basic initialization. Our properties can be  initialized, means the object was created. ngOnInit() will run after the constructor.

ngDoCheck() ---> Called during every change detection run. Runs multiple times, ngDoCheck() is done in a very effecient way. It doesn't cost a lot of performance. Partcularly great to use, when we have something to do on every change detection cycle, maybe manually inform Angular about some change that it would not be able to detect otherwise. 

ngAfterContentInit() ---> Called after content (ng-content) has been projected into view. So the view of the parent component escpecially a part that will get added to our component eventually, this hook runs.

ngAfterContentChecked() ---> Called every time the projected component has been checked.

ngAfterViewInit() ---> Called after the component's view (and child views) has been initialized. 

ngAfterViewChecked() ---> Called every time the view (and child views) have been checked

ngOnDestroy() ---> Called once the component is about be destroyed. Great for clean up work, called right before the object itself will be destroyed by Angular.


			LIFECYCLE HOOKS AND TEMPLATE ACCESS
Template Access is possible only after ngAfterViewInit() hook is called, not before that. ngAfterViewInit gives you access to the template elements, you can access them and use their values; But before this content is reached, we can't do that; i.e., can't check the value of some element in DOM, because it hasn't been rendered yet!


			GETTING ACCESS TO ng-content with @ContentChild
If the content is going to passed to another component via ng-content, you can get access to the element via @ContentChild() as we get with ViewChild() had that element been in the same component in which wish to access. We get access to the content only after ngAfterContentInit life-cycle gets called.


			DIRECTIVES DEEP DIVE
Recap of Attribute directive vs Structural Directive:
	- Attribute directives sit on elements just like attributes, through them we have no capability to destroy an element from the DOM whereas structural directives too sit on the elements as attributes only but with a leading star(e.g.: *ngIf)(for desugaring) and they are capable of changing the structure of DOM (can destroy/add elements) around this element.
	- Attribute Directives look like a normal HTML Attribute (possibly with databinding or event binding). Only affect/change the element they are added to.

Recap of ngFor and ngIf:
	- We can't have multiple template bindings on one element. Use only one attribute prefixed with *, so on same element you can't have ngFor and ngIf! Can't have multiple structural directives on same element.

Recap of ngClass and ngStyle:
	- [ngClass] = "{oddClass: number%2 !== 0}"
	The property is the class-name to be applied if the value would equate to true on the right side of ':'
	- '[]' (sqaure brackets) indicate that we are binding to some property on our NG class directive
	- [ngStyle]="{backgroundColor: number % 2 !== 0 ? 'yellow' : 'transparent'}"

Creating a basic directive:
	Create a file named 'basic-highlight.directive.ts'
Code:

import { Directive, ElementRef, OnInit } from "@angular/core";

@Directive({
    // selector: 'appBasicHighlight' // should be a unique selector, typically given a camelCase notation, 'appBasicHighlight' would select it by element
    selector: '[appBasicHighlight]' //selection by attribute

})

//The idea is to change the backgroundColor when this directive is used for an element, thus we will need access of the element, Angular gives us this access.

// We can inject the element the directive sits on into this directive. We do inject by adding the constructor and passing the argument that we need and Angular will create the object and pass this arguement.
export class BasicHighlightDirective implements OnInit{
    //adding 'private' makes this a property of this class as well and automatically assigns this value, the instance we are getting to this property.
    constructor(private elementRef: ElementRef){
    }

    ngOnInit(): void {
        this.elementRef.nativeElement.style.backgroundColor = 'green'
    }
}

To use this directive add to the declarations array in app.module.ts,
and in the tempate of the component where you want to use it, pass it like an attribute, e.g.:  <p appBasicHighlight>Style me with basic directive!</p>

Using the Renderer to build a better Attribute Directive:
	- Earlier, we used ElementRef to access and modify, which is not the best way to modify our template: Since, acccessing elements directly like this is not a good practice, should use different tool 'renderer'; Angular is able to render templates without a dom, then these properties might not be availabe so then this methods would fail or throw error.
	- To create a directive through cli: ng g d directive-name

Renderer code example:

import { Directive, ElementRef, OnInit, Renderer2 } from '@angular/core';

@Directive({
  selector: '[appBetterHighlight]'
})
export class BetterHighlightDirective implements OnInit{

  constructor(private elementRef: ElementRef, private renderer: Renderer2) { }

  // to use render, call the property and there are a couple of helper methods we can use to work with the DOM, we chose setStyle (to set the style of the element, this method takes 3 required parameters (element (not the reference, but the underlying element!, hence nativeElement), style-name you wish to set, style-name-value the value of that style property ) and 1 optional paramter (flag, e.g.: !important))
  ngOnInit(): void {
    this.renderer.setStyle(this.elementRef.nativeElement, 'background-color', 'blue')
  }
}


Why renderer is a better approach of accessing the dom - Angular is not limited to running in the browser, it for example works with service workers and in these environments we might not have access to the DOM. So, in that case of directly accessing and modifyingthe DOM using elementRef way would give an error in some circumstances. Hence, it is a better practice to use the renderer for DOM access and to use the methods the renderer provides to access the DOM.


Using HostListener to Listen to Host Events:
	To make the directive respond to events thate are related to the element on which the directives sits on, we can make use of HostListener.
E.g.:

In better-highlight.directive.ts

@HostListener('mouseenter') mouseHover(eventData: Event){
    this.renderer.setStyle(this.elementRef.nativeElement, 'background-color', 'blue')    
  }

  @HostListener('mouseleave') mouseLeave(eventData: Event){
    this.renderer.setStyle(this.elementRef.nativeElement, 'background-color', 'transparent')
  }
  
Using HostBinding to Bind to Host Properties:
	-   @HostBinding('style.backgroundColor') backgroundColor: string = 'transparent';
Now we can change this property via this.backgroundColor and that would change the backgroundColor of the element

@HostListener('mouseenter') mouseHover(eventData: Event) {
    // this.renderer.setStyle(
    //   this.elementRef.nativeElement,
    //   'background-color',
    //   'blue'
    // );
    this.backgroundColor = 'blue';
  }

Binding to Directive properties:
	Say, you wanted to change some color dynamically instead of hardcoding in your directive, in that case we can make use of Custom Property Binding (Custom event-binding also works in directive; not used that often) @Input() and calling that property in the element on which the directive is sitting.
E.g.:
In better-highlight.directive.ts
@Input() defaultColor: string = 'transparent';
@Input() highlightColor: string = 'blue';

In app.component.html
<p appBetterHighlight [defaultColor]="'yellow'" [highlightColor]="'red'">Style me with better directive!</p>

We have two directive like looking things: defaultColor and highlightColor, this is just property binding.
How does angular know if we want to bind to a property of paragraph or to a property of directive
	- The angular checks our own directives first before it reaches the native properties of the elements. Thus we can bind to properties of our own directives by placing them on the same element enclosed in square brackets.

In case of ngClass directive, it itself is enclosed within square brackets - it is a typical use case especially if you only have one property to bind to, an alias can be provided

@Input('appBetterHighlight') highlightColor: string = 'blue';
Here appBetterHighlight would be the alias.


<!-- Trying the setting of the alias for highlightColor -->
      <!-- <p appBetterHighlight [defaultColor]="'yellow'" [highlightColor]="'red'">Style me with better directive!</p> -->
      <p [appBetterHighlight]="'red'" [defaultColor]="'yellow'">
        Style me with better directive!
      </p>

Note:
about property binding in general, if we pass a string to a property as square brackets and single quotation marks: [appBetterHighlight]="'red'"
A shortcut would be removing the square bracktes and removing the single quotation mark. (Speacial case only when passing data as string, passing data via property-binding without square brackets work! (also ommit the single quotation mark))

What happens behind the scenes on Structural Directives -
	A star before the direcive indicates angular that this is a structural directive. Why? - Structual directives with a star are just a nicer way for us to use them. Behind the scenes, Angular will transform them into something else, becuase there is no star in Angular syntax when using directives, property binding, etc. There is only property binding, event binding, two-way binding and string interpolation. So behind the scenes, Angular needs to transform the ngIf/ngFor usage into something where we end up with these tools (property-binding and so on).
	
ng-template is an element which itself is not rendered, but which allows us to define a template in the end for Angular to use once it determines that this template some element, needs to be rendered becuase this condition is true in this case.

The code with structural directive gets transformed to ng-template with property binding behind the scenes, so below two snippets represent exact same thing, the latter is the transformed version used by Angular:

<div *ngIf="!onlyOdd">
          <li
            class="list-group-item"
            [ngClass]="{ even: even % 2 === 0 }"
            [ngStyle]="{
              backgroundColor: even % 2 !== 0 ? 'yellow' : 'transparent'
            }"
            *ngFor="let even of evenNumber; let i = index"
          >
            {{ even }}
          </li>
        </div>
        
<ng-template [ngIf]="!onlyOdd">
          <div>
            <li
              class="list-group-item"
              [ngClass]="{ even: even % 2 === 0 }"
              [ngStyle]="{
                backgroundColor: even % 2 !== 0 ? 'yellow' : 'transparent'
              }"
              *ngFor="let even of evenNumber; let i = index"
            >
              {{ even }}
            </li>
          </div>
        </ng-template>        

Building a structural directive
	@Input() selectorName;
	selectorName will hold the condition we get
A method that will be executed whenever that condition changes (some input parameter changes) will be a setter method, hence we use set keyword.

@Input() set selectorName(), hence this selectorName() is now turned into a method, though technically it is important to understand this still is a property!. It is the setter of the property which is a method which gets executed whenever the property changes i.e. when the condition we pass changes or some paramter of this condition. It would receive a boolean value.

@Input() set selectorName(condition: boolean){}

what you want to display on if the condition is true = template (passed to constructor as templateRef)


where to display/render = view-container
constructor(private templateRef: TemplateRef<any>, private viewContainer: ViewContainer)

@Input() set selectorName(condition: boolean){
	if(condition){
	this.viewContainer.createEmbeddedView(this.templateRef);
	} else {
	this.viewContainer.clear();
	}
	
Code for custom structural directive:
unless.directive.ts

import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';

@Directive({
  selector: '[appUnless]',
})
export class UnlessDirective {
  @Input() set appUnless(condition: boolean) {
    if (!condition) {
      this.vcRef.createEmbeddedView(this.templateRef);
    } else {
      this.vcRef.clear();
    }
  }

  constructor(
    private templateRef: TemplateRef<any>,
    private vcRef: ViewContainerRef
  ) {}
}


In app.component.html
<div *appUnless="onlyOdd">
          <li
            class="list-group-item"
            [ngClass]="{ even: even % 2 === 0 }"
            [ngStyle]="{
              backgroundColor: even % 2 !== 0 ? 'yellow' : 'transparent'
            }"
            *ngFor="let even of evenNumber; let i = index"
          >
            {{ even }}
          </li>
        </div>
 
 ngSwitch - another built-in structural directive -
 	Better to be used when creating too many ngIf condition checks. ngSwitch has to be bound to a component property, cases are what needs to be done when the property matches the case.
 	
 	
       <div [ngSwitch]="value">
        <p *ngSwitchCase="5">Value is 5</p>
        <p *ngSwitchCase="10">Value is 10</p>
        <p *ngSwitchCase="15">Value is 15</p>
        <p *ngSwitchDefault>Default value</p>
      </div>
      
      
      SERVICES AND DEPENDENCY INJECTION
What are services -
	Uses case when we want to avoid duplication of code and for storing data and providing data or to establishing commnuication between the components, services come into the play. Service is basically just another piece(class) in your Angular application which acts as a central repository/business unit. Something where you can store or centralize your code in.
	
	
A service is just a normal typescript class, we don't attach decorator like @Service() as in the case of Directive (@Directive()) or Component (@Component()).
We can create instances of services manually in the components we want to use them, but that's a wrong way, that's not how services are used in angular. Angular provides a much better way to getting access to your services, therefore the instances should not be created manually.

Angular Dependency Injector = tool offered by Angular to access the services.
Dependency = a class of ours will depend on. For example, a component that uses logging will be dependent on logging service, because we want to call a method in that service. 

Dependency injector simply injects this dependency (an instance of this class, here logging service class) into our component automatically. We just need to inform Angular that we require such a instance. We add a constructor to the class where we require the service, bind a typescript property to type-assignment which is the class you want to get injected (basically, service class name).

A Typescript shortcut to add an accessor in front of the name of the argument to instantly create a property with the same name and bind the value to it.
	constructor(private loggingService: LoggingService)
	
This way of instanting a property in the constructor informs angular that we will need an instance of this logging service. This way Angular knows what we want, but it doesn't kow how to give us such an instance, for that we need to register service to the provioder in the component. Provide simply means we tell Angular how to create it. To do that you need to add another property called provides in the component decorator, to that array pass the class name of the service, e.g.:

@Component({
  selector: 'app-new-account',
  templateUrl: './new-account.component.html',
  styleUrls: ['./new-account.component.css'],
  providers: [LoggingService]
})
export class NewAccountComponent {
 constructor(private loggingService: LoggingService){}
 
 onInit(){
 this.loggingService.logStatusChange('active');
}

This way, we are not creating the instance manually,but Angular does it for us now.

Alternative Injection Syntax:
	Injecting dependenices into components via the constructor functions is the most common way, however there is an alternative way of injecting dependencies - via Anguar's inject() function.
e.g.:

import { Component, Input, Output, inject } from '@angular/core'; 
@Component(...)
export class AccountComponent { 
 private loggingService?: LoggingService; // <- must be added
 constructor() {
    this.loggingService = inject(LoggingService);
  }
 }
 
Understanding the Hierarchical Injector:
	Angular Dependency injector is hierarchical injector, i.e. if we provide a service is some place of our app, say one component, the Angular framework knows how to create an instance of that service for this component and all its child components!! And thus, all the sub-components in the tree from where this service was provided will receive the same instance of the service.
	Other places to provide service:
		1. The highest possible level - 'AppMoule' - Same instance of service is available Application-wide.
		2. The next level - 'AppComponent' - Same instance of service is available for all components (but 'not for other services'!)
		3. The lowest level - 'Any other component' - Same instance of  service is available for the Component and all its schild components. This will actually even override if we were to provide the same service on a higher level.
		
Providers array basically tells Angular which instance we want, hence if you want that child components should use the same instance as that of the parent component, having providers array in parent component containing the instance and the child component's providers array should not contain the instance or else it would be treated as the different instance if child component's providers array contains the name of that class too!

Injecting Services into Services
	For that the service that needs to injected has to be used in providers array in app.module.ts. When we inject a service into something, this something needs to have some metdata attached to it, in case of component it has some metadata becuase we have @Component, with Directive we have metadata with @Directive but with service we don't have @Service hence no metadata that way. Angular requires us to attach some metadata if we want to inject the service. In case of a service injecting another service, we should attach a specific metadata - @Injectable. This tells Angular that something can be injected in there. Add @Injectable() where you want to inject something (not at what you want to inject).

Note: As per newer versions of Angular, it is recommended that you always add @Injectable, makes no technical difference right now, but might make in future versions. So as a habit, you should use @Injectable() in all the services.

Using Services for cross component communication
	To enable cross component communication, you can create an event emitter in the service, e.g.:
	In accounts.service.ts:
		statusUpdated = new EventEmitter<string>();
To emit an event, in the component file use this object of event-emitter:
	In account.component.ts:
		this.accountsService.statusUpdated.emit(status);
To listen(subscribe) to this event, use the subscribe in the component, you want to listen to, e.g.:
	In new-account.component.ts:
		this.accountsService.statusUpdated.subscribe((status: string) 			=> alert('New Status: ' + status));
		
A Different way of Injecting Services -
	We can provide application-wide services in a different way. Instead of adding service class to the providers[] array in AppModules, you can set the following config in @Injectable()
	@Injectable({providedIn: 'root'})
	export class MyService { . . . }
This is same as
	export class MyService { . . . }
	and 
	import { MyService } from './path/to/my.service';
 
	@NgModule({
	    ...
	    providers: [MyService]
	})
	export class AppModule { ... }
	
With the providedIn syntax, services can be loaded lazily by Angular (behind the scenes) and redundant code can be removed automatically. This can lead to better performance and loading speed.


			ROUTING
Angular ships with its own router which allows you to change the URL in the URL bar and still only use one page, but exchange major parts or a lot of parts of that page. To the user, it looks like a new page was loaded because maybe only the header is the same, but behind the scenes, it is actually javascript changing a lot of parts in your DOM in your page making it look like a new page was rendered, but in the end it is still a single-page-application!

Setting up and Loading Routes:
	Routes can be defined in app.module.ts since they are responsible for our whole application. An array containing each route as a Javascript object can be set up. A route JS object needs to have two properties essentially - path(string; what gets in the url after domian, don't use slash '/'), component(what should happen when this path is reached -action, typically a component is specified, ultimately which component's template should be rendered in the end).E.g.:
		import { Routes } from '@angular/router'
		const appRoutes: Routes = [
		  {path: '', component: HomeComponent},
		  {path: 'servers', component: ServersComponent},
		  {path: 'users', component: UsersComponent},
		]
This constant appRoutes alone will do nothing, we need to inform Angular to use this constant, for that we need to register these routes in our application by adding a new import-RouterModule (from @angular/core) in imports array. This import adds the routing functionality in our application, but still our routes are not registered. Hence RouterModule has a special method - .forRoot(appRoutes)

This .forRoot() allows us to register some routes for our main application here.

//app.module.ts

import { RouterModule, Routes } from '@angular/router';
const appRoutes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'servers', component: ServersComponent },
  { path: 'users', component: UsersComponent },
];

@NgModule({
...
imports: [BrowserModule, FormsModule, RouterModule.forRoot(appRoutes)],
  providers: [ServersService],
  bootstrap: [AppComponent],
 })
 
Now our routes are registered in our Angular app on this RouterModule, hence Angular now knows our routes! Now we need to add a place to our application where the currently selected component would be rendered. The right place to inform Angular where to load the compoent is the place where you actually want to render your route, by using a special directive that is shipped with Angular, the <router-outlet></router-outlet>, it looks like a component but it is still a directive (directives may have any selector including the component/element-style selector). This router-outlet simply marks the place in our document where we want Angular router to load the component of the currently selected route.
 
 
 Navigating with our router links
 	If we add the links via href attribute of a tag, this leads to app reload(refresh) with every link we click. With every link click, a new request gets sent to the server and it returns us a new page. Since, this page is still our Angular app with routes registered on it, it is able to give us the correct route. Not the best behaviour: 
 	Since, it restarts our app on every navigation, which means our whole application state will be lost!
 	<ul class="nav nav-tabs">
        <!-- Adding links via href makes the app to reload to display the component -->
        <li role="presentation" class="active"><a href="/">Home</a></li>
        <li role="presentation"><a href="/servers">Servers</a></li>
        <li role="presentation"><a href="/users">Users</a></li>
      </ul>
      
	For navigation, there is a special directive provided in Angular - routerLink. 'routerLink' is able to parse a string. This will tell Angular that this element on which routerLink is placed here, will serve as a link in the end, but will handle a click differently (no refresh => no application state loss).
	<li role="presentation" class="active"><a routerLink="/">Home</a></li>
        <li role="presentation"><a routerLink="/servers">Servers</a></li>
Another way of using routerLink is with property binding (more specifically to bind to some non-string data)
	<li role="presentation"><a [routerLink]="['/users']">Users</a></li>

If you want to construct a URL say, localhost:4200/users/user-detail, it would be <li role="presentation"><a [routerLink]="['/users','user-detail']">Users</a></li>

Note: We don't give the leading slash(required only for to make this an absolute path) for the subsequent parts/segments of the urls as elements to this array here. This way of binding to an array gives us more fine-grain control over routerLink. (In the array, we specify all the segments of the path as elements in this array). This array notation allows you to construct more complex paths very easily.

RouterLink, the directive catches the click on the element prevents the defualt (which would be to send a request to server, instead it analyzes what we passed in the component to routerLink directive (path/array of path elements), parses it, checks if it finds a fitting route in our configuration.). RouterLink also provides speed as it is much faster than reloading the page all the time.

Understanding Navigation Paths:
	Navigation paths when used with leading slash to the routerLinks gets appended to the root-domain (e.g.: localhost:4200/). These are called absolute paths.
	
	Navigation paths when used without a leading slash or the ones that starts with dot(s) (., like in directory) are called relative paths and are appended to the the current path (not necessarily to the root domain)
	
Styling Active Router Links:
	Angular gives a specific directive for this: 'routerLinkActive'. This directive can be added to a warpping element or on the link element (a-href tag) itself. It will attach the class you specify in the value of this diective as a string. It will dynamically attach the class to the element it sits on. routerLinkActive analyses your currently loaded path that checks which links lead to a router which uses this path and by default it marks an element as active (adds the given css class) if it contains the path you are on or if this link is part of the path which is currently loaded. To avoid that an empty path link (say, homepage at '/') be marked as active even if move away to some other tab (say, users at '/users') in navigation bar, add some configuration to the routerLinkActive directive with routerLinkActiveOptions directive which needs some property binding because we don't just pass a string there, we can pass a JS object
	e.g.: [routerLinkActiveOptions]="{exact: true}"
exact is a reserved property on this object which you pass to routerLinkActiveOptions, which will tell angular, only add this routerLinkActive class if the exact full path is what the link leads to in routerLink.

Navigating Programatically:
	Angular Router is injectable and we can navigate to a different route via TS code. 'navigate' property on router object can be used, an array of route(s) where we wish to navigate to is passed as an arguement.
 E.g.:
 import { Router } from '@angular/router';
 ....
 constructor(private router: Router) { }
 
 onLoadServers(){
    this.router.navigate(['/servers'])
  }
 (We could have passed a relative path, but here we would have to control what this should be relative to)

Using Realtive Paths in Prorammatic Navigation
	Even if we pass the relative path (without '/') to the naviagte method of Router, it still take is absolute exact path (taking root domain and appending to it). When using routerLink we do get an error sometimes when we don't a proper relative path (path that exists). Unlike, the routerLink the navigate method doesn't know on which route you are currently on, the routerLink always knows on which component it sits, in which component's template therefore knows what the currently loaded route is. To tell navigate method, where we are currently in (the current route), we need to pass a second arguement to navigate method, a JS object which can be used to configure the navigation action, one of the properties is 'relativeTo' property, which basically defines relative to which route, this link should be loaded (by default, it is always the root domain). relativeTo property has to given a route as value for which we used ActivatedRoute (another service which we need to inject.) ActivatedRoute simply injects the currently active route. So now navigate property will be finding for the relativeRoute in connection with the relativeTo route.
	
E.g.:
constructor(
    private serversService: ServersService,
    private router: Router,
    private activatedRoute: ActivatedRoute
) {}

...
this.router.navigate(['servers'],{relativeTo: this.activatedRoute});

Passing Parameters to Routes:
	We can add parameters(dynamic segments) to our route by adding a colon followed by any name (say, id). Later, we would be able to retrieve the parameter inside of the loaded component by that name you specify here (i.e. by id). Colon tells angular that this is a dynamic part of the path.
E.g.:   { path: 'users/:id', component: UserComponent },

Fetching Route Parameters:
	We can make use of activatedRoute (from @angular/core) in the component which gets loaded to get the route parameter by using snapshot property. Snapshot property of our currrently active route we have 'params' JS object and there we need to check for the name we used in setting up that route for parameter. We can have as many route parameters we want.
E.g.: id: this.route.snapshot.params['id'],
      name: this.route.snapshot.params['name'],
